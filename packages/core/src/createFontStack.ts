import { AtRule } from 'csstype';
import { round } from './round';

const formatValue = (value: number) => `${round(value * 100)}%`;

export const toCssProperty = (property: string) =>
  property.replace(/([A-Z])/g, (property) => `-${property.toLowerCase()}`);

interface FontMetrics {
  /** Font family name as authored by font creator */
  familyName: string;
  /** The height of capital letters above the baseline */
  capHeight: number;
  /** The height of the ascenders above baseline */
  ascent: number;
  /** The descent of the descenders below baseline */
  descent: number;
  /** The amount of space included between lines */
  lineGap: number;
  /** The size of the fontâ€™s internal coordinate grid */
  unitsPerEm: number;
  /** The average width of lowercase characters (currently supports latin only) */
  xWidthAvg: number;
  // Allows full metrics interface to be passed in
  // while only type checking the required properties
  [key: string | number]: unknown;
}

interface OverrideValuesParams {
  metrics: FontMetrics;
  fallbackMetrics: FontMetrics;
}
const calculateOverrideValues = ({
  metrics,
  fallbackMetrics,
}: OverrideValuesParams): AtRule.FontFace => {
  // Calculate size adjust
  let sizeAdjust = 1;
  if (
    typeof metrics.xWidthAvg === 'number' &&
    typeof fallbackMetrics.xWidthAvg === 'number'
  ) {
    const preferredFontXAvgRatio = metrics.xWidthAvg / metrics.unitsPerEm;
    const fallbackFontXAvgRatio =
      fallbackMetrics.xWidthAvg / fallbackMetrics.unitsPerEm;

    if (preferredFontXAvgRatio && fallbackFontXAvgRatio) {
      sizeAdjust = preferredFontXAvgRatio / fallbackFontXAvgRatio;
    }
  }
  const adjustedEmSquare = metrics.unitsPerEm * sizeAdjust;

  // Calculate metric overrides for preferred font
  const ascentOverride = metrics.ascent / adjustedEmSquare;
  const descentOverride = Math.abs(metrics.descent) / adjustedEmSquare;
  const lineGapOverride = metrics.lineGap / adjustedEmSquare;

  // Conditionally populate font face properties and format to percent
  const fontFace: AtRule.FontFace = {};
  if (ascentOverride) {
    fontFace['ascentOverride'] = formatValue(ascentOverride);
  }
  if (descentOverride) {
    fontFace['descentOverride'] = formatValue(descentOverride);
  }
  if (lineGapOverride) {
    fontFace['lineGapOverride'] = formatValue(lineGapOverride);
  }
  if (sizeAdjust !== 1) {
    fontFace['sizeAdjust'] = formatValue(sizeAdjust);
  }

  return fontFace;
};

type FontFace = {
  '@font-face': Omit<AtRule.FontFace, 'src' | 'fontFamily'> &
    Required<Pick<AtRule.FontFace, 'src' | 'fontFamily'>>;
};
const toCssString = (fontFaces: FontFace[]) => {
  return fontFaces
    .map(({ '@font-face': { fontFamily, src, ...restFontFaceProperties } }) => {
      const fontFace = [
        '@font-face {',
        `  font-family: ${fontFamily};`,
        `  src: ${src};`,
      ];

      Object.keys(restFontFaceProperties).forEach((property) => {
        fontFace.push(
          `  ${toCssProperty(property)}: ${
            restFontFaceProperties[
              property as keyof typeof restFontFaceProperties
            ]
          };`,
        );
      });

      fontFace.push('}');

      return fontFace.join('\n');
    })
    .join('\n');
};

export const quoteIfNeeded = (name: string) =>
  !/^[a-zA-Z][^"'][a-zA-Z\d-]+[a-zA-Z\d]$/.test(name) ? `'${name}'` : name;

type AdditionalFontFaceProperties = Omit<
  AtRule.FontFace,
  | 'src'
  | 'fontFamily'
  | 'ascentOverride'
  | 'descentOverride'
  | 'lineGapOverride'
  | 'sizeAdjust'
>;
type CreateFontStackOptions = {
  /** Additional properties to add to the generated `@font-face` declarations.
   *
   * Accepts all valid `@font-face` properties except the following which are
   * generated by Capsize: `src`, `fontFamily`, `ascentOverride`,
   * `descentOverride`, `lineGapOverride`, `sizeAdjust`.
   */
  fontFaceProperties?: AdditionalFontFaceProperties;
};
type FontFaceFormatString = {
  /** Choose between returning CSS as a string for stylesheets or `style` tags,
   * or as a style object for CSS-in-JS integration.
   *
   * Default: `styleString`
   */
  fontFaceFormat?: 'styleString';
};
type FontFaceFormatObject = {
  fontFaceFormat?: 'styleObject';
};

export function createFontStack(
  font: FontMetrics[],
  options?: CreateFontStackOptions & FontFaceFormatString,
): { fontFamily: string; fontFaces: string };
export function createFontStack(
  font: FontMetrics[],
  options?: CreateFontStackOptions & FontFaceFormatObject,
): { fontFamily: string; fontFaces: FontFace[] };
export function createFontStack(
  [metrics, ...fallbacks]: FontMetrics[],
  optionsArg: CreateFontStackOptions = {},
) {
  const { fontFaceFormat, fontFaceProperties } = {
    fontFaceFormat: 'styleString',
    ...optionsArg,
  };
  const { familyName } = metrics;

  const fontFamilys: string[] = [quoteIfNeeded(familyName)];
  const fontFaces: FontFace[] = [];

  fallbacks.forEach((fallbackMetrics) => {
    const fontFamily = `'${familyName} Fallback${
      fallbacks.length > 1 ? `: ${fallbackMetrics.familyName}` : ''
    }'`;

    fontFamilys.push(fontFamily);
    fontFaces.push({
      '@font-face': {
        ...fontFaceProperties,
        fontFamily,
        src: `local('${fallbackMetrics.familyName}')`,
        ...calculateOverrideValues({
          metrics,
          fallbackMetrics,
        }),
      },
    });
  });

  return {
    fontFamily: fontFamilys.join(', '),
    fontFaces: {
      styleString: toCssString(fontFaces),
      styleObject: fontFaces,
    }[fontFaceFormat],
  };
}
